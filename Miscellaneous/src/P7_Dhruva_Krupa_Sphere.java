import gpdraw.DrawingTool;
import gpdraw.SketchPad;

import java.awt.Color;
import java.awt.Point;

/*
 * Name: Krupa Dhruva
 * Date: September 11, 2020
 * Period: 7
 * Time Taken: About 4 hours
 *
 * Lab Reflection:
 * I learned one way to avoid code duplication by reusing constructors.
 * Overall, I enjoyed exploring the different ways to draw a sphere but the most challenging
 * part that I did not figure out yet is how to evenly shade the filled in sphere if the
 * light source is not directly hitting the center of the sphere. I am really proud of the wired
 * sphere where I used multiple ovals to draw the wired frames. I also proud of using multiple circles
 * with decreasing radius to show how the gradients are smoothly transitioning.
 */

/**
 * Class implementing sphere appearing like wireframe or solid.
 *
 * <p>Wireframe is generated by drawing intersecting ovals along X and Y axis. Ovals give an
 * appearance of rotated circle along Z axis.
 *
 * <p>Solid appearing sphere is rendered by drawing reducing sized filled circles with color
 * transitioning from actual sphere color to white. This simulates a light shining on a sphere.
 */
public class P7_Dhruva_Krupa_Sphere {
    /** Pen to draw the shape */
    private final DrawingTool pen;
    /** Origin of the sphere */
    private Point origin;
    /** View point */
    private Point viewPoint;
    /** Sphere radius */
    private int radius;
    /** Sphere color */
    private Color color;
    /** Number of wire frames to draw */
    private int numberOfFrames;

    public void setOrigin(Point origin) {
        this.origin = origin;
    }

    public void setViewPoint(Point viewPoint) {
        this.viewPoint = viewPoint;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    public void setColor(Color color) {
        this.color = color;
    }

    public void setNumberOfFrames(int numberOfFrames) {
        this.numberOfFrames = numberOfFrames;
    }

    public DrawingTool getPen() {
        return pen;
    }

    public Point getOrigin() {
        return origin;
    }

    public Point getViewPoint() {
        return viewPoint;
    }

    public int getRadius() {
        return radius;
    }

    public Color getColor() {
        return color;
    }

    public int getNumberOfFrames() {
        return numberOfFrames;
    }

    /** Constructs a sphere with wire frames with default parameters */
    public P7_Dhruva_Krupa_Sphere(DrawingTool pen) {
        this.pen = pen;
        this.origin = new Point(200, 0);
        this.viewPoint = origin.getLocation();
        this.radius = 100;
        this.color = Color.BLACK;
        this.numberOfFrames = 0;
    }

    /**
     * Simple driver to test the sphere
     *
     * @param args Array of strings - command line arguments
     */
    public static void main(String[] args) {
        DrawingTool pen = new DrawingTool(new SketchPad(800, 600, 5L));

        // Draw a wireframe model of sphere
        P7_Dhruva_Krupa_Sphere sphere = new P7_Dhruva_Krupa_Sphere(pen);
        sphere.setOrigin(new Point(-200, 0));
        sphere.setRadius(100);
        sphere.setNumberOfFrames(30);
        sphere.draw();

        // Draw a solid sphere
        sphere.setNumberOfFrames(0);
        sphere.setOrigin(new Point(200, 0));
        sphere.setViewPoint(new Point(150, 50));
        sphere.draw();

        System.out.printf(
                "Sphere geometric properties: radius=%d, circumference=%.2f, area=%.2f,"
                        + " volume=%.2f%n",
                sphere.getRadius(), sphere.circumference(), sphere.area(), sphere.volume());
    }

    /**
     * Compute the volume of the sphere
     *
     * @return Volume of sphere
     */
    public double volume() {
        return (4.0 / 3.0) * Math.PI * Math.pow(radius, 3);
    }

    /**
     * Compute the surface area of the sphere
     *
     * @return Surface area of sphere
     */
    public double area() {
        return 4.0 * Math.PI * Math.pow(radius, 2);
    }

    /**
     * Compute the circumference of the sphere
     *
     * @return Circumference of sphere
     */
    public double circumference() {
        return 2.0 * Math.PI * radius;
    }

    /**
     * Implements 2 versions of drawing a sphere based on constructor used to instantiate an object
     *
     * <p>Wireframe: Draws a wireframe model of a sphere built with perpendicular intersecting ovals
     * of varying minor/major axis
     *
     * <p>Solid: Draws a shaded sphere drawn by filling gradually reducing circles with color
     * changing from actual color at the periphery to white at the center to simulate a focused
     * light source
     */
    public void draw() {
        pen.up();
        pen.move(origin.getX(), origin.getY());
        pen.down();

        if (numberOfFrames > 0) {
            pen.setColor(color);
            int majorAxis = 2 * radius;
            for (int count = 0; count < numberOfFrames; ++count) {
                int minorAxis = majorAxis - (count * majorAxis / numberOfFrames);
                pen.drawOval(majorAxis, minorAxis);
                pen.drawOval(minorAxis, majorAxis);
            }
        } else {
            // Determine RGBA so that we incrementally transition from that color
            // starting outside to white inside
            float[] rgba = color.getRGBComponents(null);

            // Draw circles from darker outer to lighter inside
            int chunks = Math.max((int) (radius), 200);
            double viewOffset = origin.distance(viewPoint);

            double currentRadius = radius;
            double xDelta = (viewPoint.getX() - origin.getX()) / chunks;
            double yDelta = (viewPoint.getY() - origin.getY()) / chunks;
            for (int count = 0; count < chunks; ++count) {
                pen.setColor(
                        new Color(
                                rgba[0] + (1.0f - rgba[0]) * count / chunks,
                                rgba[1] + (1.0f - rgba[1]) * count / chunks,
                                rgba[2] + (1.0f - rgba[2]) * count / chunks,
                                rgba[3]));
                pen.fillCircle(currentRadius);
                currentRadius -= ((double) radius / chunks);

                // Move origin towards view point at same rate as reducing radius
                if (viewOffset > 0.0) {
                    pen.up();
                    pen.move(pen.getXPos() + xDelta, pen.getYPos() + yDelta);
                    pen.down();
                }
            }
        }
    }
}
